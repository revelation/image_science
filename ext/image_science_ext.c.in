/*
 * Provides a clean and simple API to generate thumbnails using
 * FreeImage as the underlying mechanism.
 *
 * For more information or if you have build issues with FreeImage, see
 * http://seattlerb.rubyforge.org/ImageScience.html
 *
 */

#include "ruby.h"
#include "FreeImage.h"
#include <sys/stat.h>

#define GET_BITMAP(name) Data_Get_Struct(self, FIBITMAP, (name)); if (!(name)) rb_raise(rb_eTypeError, "Bitmap has already been freed")
#define RB_BOOL(value) (value ? Qtrue : Qfalse)

VALUE isc;               /* ImageScience class */
VALUE isc_image_types;   /* ImageScience::ImageTypes module */
VALUE isc_image_formats; /* ImageScience::ImageFormats module */
VALUE isc_image_filters; /* ImageScience::ImageFilters module */
VALUE isc_color_chan;    /* ImageScience::ColorChannels module */
VALUE isc_color_types;   /* ImageScience::ColorTypes module */
VALUE isc_ls_flags;      /* ImageScience::LoadSaveFlags module */

static VALUE unload(VALUE self) {
  FIBITMAP *bitmap;
  GET_BITMAP(bitmap);

  FreeImage_Unload(bitmap);
  DATA_PTR(self) = NULL;
  return Qnil;
}

static VALUE wrap_and_yield(FIBITMAP *image, VALUE self, FREE_IMAGE_FORMAT fif) {
  unsigned int self_is_class = rb_type(self) == T_CLASS;
  VALUE klass = self_is_class ? self         : CLASS_OF(self);
  VALUE type  = self_is_class ? INT2FIX(fif) : rb_iv_get(self, "@file_type");
  VALUE obj = Data_Wrap_Struct(klass, NULL, NULL, image);
  rb_iv_set(obj, "@file_type", type);
  return rb_ensure(rb_yield, obj, unload, obj);
}

static void copy_icc_profile(VALUE self, FIBITMAP *from, FIBITMAP *to) {
  FREE_IMAGE_FORMAT fif = FIX2INT(rb_iv_get(self, "@file_type"));
  if (fif != FIF_PNG && FreeImage_FIFSupportsICCProfiles(fif)) {
    FIICCPROFILE *profile = FreeImage_GetICCProfile(from);
    if (profile && profile->data) {
      FreeImage_CreateICCProfile(to, profile->data, profile->size);
    }
  }
}

static void FreeImageErrorHandler(FREE_IMAGE_FORMAT fif, const char *message) {
  rb_raise(rb_eRuntimeError,
	   "FreeImage exception for type %s: %s",
	   (fif == FIF_UNKNOWN) ? "???" : FreeImage_GetFormatFromFIF(fif),
	   message);
}

/****** helper functions ****/

/*
 * Prepare the given bitmap for saving in the specified format.
 * If a new bitmap is required, returns a bitmap, else returns NULL.
 */
static FIBITMAP *
_prepare_bitmap_for_save(FIBITMAP *bitmap, FREE_IMAGE_FORMAT fif)
{
  FIBITMAP *new_bitmap = NULL;

  if (fif == FIF_PNG) FreeImage_DestroyICCProfile(bitmap);

  if (fif == FIF_JPEG && FreeImage_GetBPP(bitmap) != 24) {
    new_bitmap = FreeImage_ConvertTo24Bits(bitmap);
  }
  if (fif == FIF_GIF && FreeImage_GetBPP(bitmap) != 8) {
    new_bitmap = FreeImage_ConvertTo8Bits(bitmap);
  }

  return new_bitmap;
}

/****** Class methods ******/

/*
 * call-seq:
 *   with_image(filename) { |img| ... }
 *
 * The top-level image loader opens +filename+ and then yields the image.
 */
static VALUE with_image(VALUE klass, VALUE filename) {
  FREE_IMAGE_FORMAT fif = FIF_UNKNOWN;
  int flags;
  char *input = RSTRING(filename)->ptr;
  struct stat buf;

  if (stat(input, &buf)) rb_raise(rb_eTypeError, "file not found");

  fif = FreeImage_GetFileType(input, 0);
  if (fif == FIF_UNKNOWN) fif = FreeImage_GetFIFFromFilename(input);
  if ((fif != FIF_UNKNOWN) && FreeImage_FIFSupportsReading(fif)) {
    FIBITMAP *bitmap;
    VALUE result = Qnil;
    flags = fif == FIF_JPEG ? JPEG_ACCURATE : 0;
    bitmap = FreeImage_Load(fif, input, flags);
    if (bitmap) {
      FITAG *tagValue = NULL;
      FreeImage_GetMetadata(FIMD_EXIF_MAIN, bitmap, "Orientation", &tagValue); 
      switch (tagValue == NULL ? 0 : *((short *) FreeImage_GetTagValue(tagValue))) {
      case 6:
	bitmap = FreeImage_RotateClassic(bitmap, 270);
	break;
      case 3:
	bitmap = FreeImage_RotateClassic(bitmap, 180);
	break;
      case 8:
	bitmap = FreeImage_RotateClassic(bitmap, 90);
	break;
      default:
	break;
      }

      result = wrap_and_yield(bitmap, klass, fif);
    }
    return result;
  }
  rb_raise(rb_eTypeError, "Unknown file format");
}

/*
 * call-seq:
 *   with_image_from_memory(image_data) { |img| ... }
 *
 * The top-level image loader, opens an image from the string +image_data+
 * and then yields the image.
 */
static VALUE with_image_from_memory(VALUE klass, VALUE image_data) {
  FREE_IMAGE_FORMAT fif = FIF_UNKNOWN;

  Check_Type(image_data, T_STRING);
  BYTE *image_data_ptr    = (BYTE*)RSTRING_PTR(image_data);
  DWORD image_data_length = RSTRING_LEN(image_data);
  FIMEMORY *stream = FreeImage_OpenMemory(image_data_ptr, image_data_length);

  if (NULL == stream) {
    rb_raise(rb_eTypeError, "Unable to open image_data");
  }

  fif = FreeImage_GetFileTypeFromMemory(stream, 0);
  if ((fif == FIF_UNKNOWN) || !FreeImage_FIFSupportsReading(fif)) {
    rb_raise(rb_eTypeError, "Unknown file format");
  }

  FIBITMAP *bitmap = NULL;
  VALUE result = Qnil;
  int flags = fif == FIF_JPEG ? JPEG_ACCURATE : 0;
  bitmap = FreeImage_LoadFromMemory(fif, stream, flags);
  FreeImage_CloseMemory(stream);
  if (bitmap) {
    result = wrap_and_yield(bitmap, klass, fif);
  }
  return result;
}

/*
 * Returns the FreeImage library version.
 */
static VALUE get_version(VALUE self) {
  const char *version = FreeImage_GetVersion();
  return rb_str_new2(version);
}

/* 
 * Orders FreeImage to analyze the bitmap signature. The method then
 * returns one of the predefined ImageScience::ImageFormats or a bitmap
 * identification number registered by a plugin. The size parameter is
 * currently not used and can be set to 0.
 */
static VALUE file_type(VALUE self, VALUE filename) {
  char * input = RSTRING(filename)->ptr;
  FREE_IMAGE_FORMAT fif = FIF_UNKNOWN; 

  fif = FreeImage_GetFileType(input, 0); 
  if (fif == FIF_UNKNOWN) fif = FreeImage_GetFIFFromFilename(input); 
  return (fif == FIF_UNKNOWN) ? Qnil : INT2FIX(fif);
}

/*********** Instance methods ***********/

/*
 * call-seq:
 *   buffer()
 *   buffer() { |string| ... }
 *   buffer(format, flags = 0)
 *   buffer(format, flags = 0) { |string| ... }
 *
 * Returns the image in a buffer (String). Optionally accepts a file
 * format argument to convert the image to the specified format (see
 * ImageScience::ImageFormats).  If +format+ is nil, buffer() uses the
 * current file format of the image (the default).  +flags+ is optional
 * flags to send to the writer plugin (see ImageScience::LoadSaveFlags).
 */
static VALUE buffer(int argc, VALUE *argv, VALUE self) {
  VALUE str = Qnil;
  int flags;
  FIBITMAP *bitmap, *new_bitmap;
  FIMEMORY *mem = NULL;
  long file_size;
  BYTE *mem_buffer = NULL; 
  DWORD size_in_bytes = 0;
  char message[1024];
  FREE_IMAGE_FORMAT fif;
  BOOL result = 0;
  VALUE fif_arg, flags_arg;  /* optional argument */

  /* parse optional arguments: fif and flags */
  rb_scan_args(argc, argv, "02", &fif_arg, &flags_arg);
  if(NIL_P(fif_arg)) fif_arg = rb_iv_get(self, "@file_type");
  fif = NIL_P(fif_arg) ? FIF_UNKNOWN : FIX2INT(fif_arg);
  flags = NIL_P(flags_arg) ? 0 : FIX2INT(flags_arg);

  if ((fif == FIF_UNKNOWN) || !FreeImage_FIFSupportsWriting(fif)) {
    snprintf(message, 1023, "Unknown file format: %d", fif);
    rb_raise(rb_eTypeError, message);
  }

  GET_BITMAP(bitmap);

  // create a memory stream and save to it 
  new_bitmap = _prepare_bitmap_for_save(bitmap, fif);
  mem = FreeImage_OpenMemory(0,0);
  result = FreeImage_SaveToMemory(fif, new_bitmap ? new_bitmap : bitmap, mem, flags);

  if(result) {
    // get the buffer from the memory stream
    FreeImage_AcquireMemory(mem, &mem_buffer, &size_in_bytes);

    // convert to ruby string
    str = rb_str_new((char *) mem_buffer, size_in_bytes);
  }

  // clean up
  if(new_bitmap) FreeImage_Unload(new_bitmap);
  FreeImage_CloseMemory(mem); 

  // yield the string, or return it
  if (rb_block_given_p()) {
    rb_yield(str);
  } else {
    return str;
  }
}

/*
 * call-seq:
 *   crop(left, top, right, bottom)
 *   with_crop(left, top, right, bottom) { |img| ... }
 *
 * Crops an image to +left+, +top+, +right+, and +bottom+.
 * If a block is given, yields the new image, else returns
 * true on success.
 */
static VALUE with_crop(VALUE self, VALUE lv, VALUE tv, VALUE rv, VALUE bv) {
  FIBITMAP *copy, *bitmap;
  VALUE result = Qnil;
  GET_BITMAP(bitmap);

  copy = FreeImage_Copy(bitmap, NUM2INT(lv), NUM2INT(tv),
			NUM2INT(rv), NUM2INT(bv));
  if (copy) {
    copy_icc_profile(self, bitmap, copy);
    if(rb_block_given_p()) {
      result = wrap_and_yield(copy, self, 0);
    } else {
      result = Qtrue;
      unload(self);
      DATA_PTR(self) = copy;
    }
  }
  return result;
}

/*
 * Returns the height of the image, in pixels.
 */
static VALUE height(VALUE self) {
  FIBITMAP *bitmap;
  GET_BITMAP(bitmap);
  int height = FreeImage_GetHeight(bitmap);
  return INT2FIX(height);
}

/*
 * Returns the width of the image, in pixels.
 */
static VALUE width(VALUE self) {
  FIBITMAP *bitmap;
  GET_BITMAP(bitmap);
  int width = FreeImage_GetWidth(bitmap);
  return INT2FIX(width);
}

/*
 * call-seq:
 *   get_pixel_color(x, y) -> [red, green, blue]
 *
 * Returns an array representing the color of the given pixel [red,green,blue]
 */
static VALUE get_pixel_color(VALUE self, VALUE xval, VALUE yval) {
  FIBITMAP *bitmap;
  RGBQUAD rgb;
  RGBQUAD *pal;
  BYTE rgb_index;
  FREE_IMAGE_COLOR_TYPE ctype;
  VALUE out_ary = rb_ary_new2(3);
  int x = NUM2INT(xval);
  int y = NUM2INT(yval);
  int success = 0;

  GET_BITMAP(bitmap);
  ctype = FreeImage_GetColorType(bitmap);

  if(ctype == FIC_PALETTE) {
    if(FreeImage_GetPixelIndex(bitmap, x, y, &rgb_index)) {
      pal = FreeImage_GetPalette(bitmap);
      if(pal) {
	rgb = pal[rgb_index];
	success = 1;
      }
    }
  } else {
    success = FreeImage_GetPixelColor(bitmap, x, y, &rgb);
  }

  if(success) {
    rb_ary_store(out_ary, 0, INT2FIX(rgb.rgbRed));
    rb_ary_store(out_ary, 1, INT2FIX(rgb.rgbGreen));
    rb_ary_store(out_ary, 2, INT2FIX(rgb.rgbBlue));
  }

  return out_ary;
}

/*
 * call-seq:
 *   resize(width, height, filter = FILTER_CATMULLROM)
 *   resize(width, height, filter = FILTER_CATMULLROM) { |img| ... }
 *
 * Resizes the image to +width+ and +height+.  Optionally specify a filter to
 * use with the filter argument (See FreeImage::ImageFilters).
 * If a block is given, yields the new image, else returns
 * true on success.
 */
static VALUE resize(int argc, VALUE *argv, VALUE self) {
  FIBITMAP *bitmap, *image;
  VALUE width, height, filter;
  FREE_IMAGE_FILTER fi_filter;
  int w, h;

  rb_scan_args(argc, argv, "21", &width, &height, &filter);
  fi_filter = NIL_P(filter) ? FILTER_CATMULLROM : FIX2INT(filter);

  w = NUM2INT(width);
  h = NUM2INT(height);

  if (w <= 0) rb_raise(rb_eArgError, "Width <= 0");
  if (h <= 0) rb_raise(rb_eArgError, "Height <= 0");

  GET_BITMAP(bitmap);
  image = FreeImage_Rescale(bitmap, w, h, fi_filter);

  if (image) {
    copy_icc_profile(self, bitmap, image);
    if(rb_block_given_p()) {
      return wrap_and_yield(image, self, 0);
    } else {
      unload(self);
      DATA_PTR(self) = image;
    }
  }
  return image ? Qtrue : Qfalse;
}

/*
 * call-seq:
 *   save(path)
 *
 * Saves the image out to +path+. Changing the file extension will
 * convert the file type to the appropriate format.
 */
static VALUE save(VALUE self, VALUE filename) {
  int flags;
  char * output = RSTRING(filename)->ptr;
  FIBITMAP *bitmap, *new_bitmap;
  FREE_IMAGE_FORMAT fif = FreeImage_GetFIFFromFilename(output);
  if (fif == FIF_UNKNOWN) fif = FIX2INT(rb_iv_get(self, "@file_type"));
  if ((fif != FIF_UNKNOWN) && FreeImage_FIFSupportsWriting(fif)) {
    GET_BITMAP(bitmap);
    flags = fif == FIF_JPEG ? JPEG_QUALITYSUPERB : 0;
    BOOL result = 0, unload = 0;
    
    new_bitmap = _prepare_bitmap_for_save(bitmap, fif);
    result = FreeImage_Save(fif, new_bitmap ? new_bitmap : bitmap, output, flags);
    if(new_bitmap) FreeImage_Unload(new_bitmap);

    return result ? Qtrue : Qfalse;
  }
  rb_raise(rb_eTypeError, "Unknown file format");
}

/*
 * Investigates the color type of the bitmap by reading the bitmap's
 * pixel bits and analysing them.  See ImageScience::ColorTypes for
 * return values. 
 */
static VALUE colortype(VALUE self) {
  FIBITMAP *bitmap;
  GET_BITMAP(bitmap);

  return INT2FIX(FreeImage_GetColorType(bitmap));
}

/*
 * Returns the size of one pixel in the bitmap in bits. For example
 * when each pixel takes 32-bits of space in the bitmap, this method
 * returns 32. Possible bit depths are 1, 4, 8, 16, 24, 32 for
 * standard bitmaps and 16-, 32-, 48-, 64-, 96- and 128-bit for non
 * standard bitmaps.
 */
static VALUE depth(VALUE self) {
  FIBITMAP *bitmap;
  GET_BITMAP(bitmap);

  return INT2FIX(FreeImage_GetBPP(bitmap));
}

/*
 * call-seq:
 *   adjust_gamma(gamma) -> boolean
 *
 * Performs gamma correction on a 8-, 24- or 32-bit image. The gamma
 * parameter represents the gamma value to use (gamma > 0). A value of
 * 1.0 leaves the image alone, less than one darkens it, and greater
 * than one lightens it.  The method returns true on success. It
 * returns false when gamma is less than or equal to zero or when the
 * bitdepth of the image cannot be handled.
 */
static VALUE adjust_gamma(VALUE self, VALUE gamma) {
  FIBITMAP *bitmap;
  GET_BITMAP(bitmap);
  return RB_BOOL(FreeImage_AdjustGamma(bitmap, NUM2DBL(gamma)));
}

/*
 * call-seq:
 *   adjust_brightness(percentage) -> boolean
 *
 * Adjusts the brightness of a 8-, 24- or 32-bit image by a certain
 * amount. This amount is given by the percentage parameter, where
 * percentage is a value between [-100..100]. A value 0 means no
 * change, less than 0 will make the image darker and greater than 0
 * will make the image brighter.  The method returns true on
 * success, false otherwise (e.g. when the bitdepth of the image
 * cannot be handled).
 */
static VALUE adjust_brightness(VALUE self, VALUE percentage) {
  FIBITMAP *bitmap;
  GET_BITMAP(bitmap);
  return RB_BOOL(FreeImage_AdjustBrightness(bitmap, NUM2DBL(percentage)));
}

/*
 * call-seq:
 *   adjust_contrast(percentage) -> boolean
 *
 * Adjusts the contrast of a 8-, 24- or 32-bit image by a certain
 * amount. This amount is given by the percentage parameter, where
 * percentage is a value between [-100..100]. A value 0 means no change,
 * less than 0 will decrease the contrast and greater than 0 will
 * increase the contrast of the image.  The method returns true on
 * success, false otherwise (e.g. when the bitdepth of the image cannot
 * be handled).
 */
static VALUE adjust_contrast(VALUE self, VALUE percentage) {
  FIBITMAP *bitmap;
  GET_BITMAP(bitmap);
  return RB_BOOL(FreeImage_AdjustContrast(bitmap, NUM2DBL(percentage)));
}

/* Inverts each pixel data. Returns true on success. */
static VALUE invert(VALUE self) {
  FIBITMAP *bitmap;
  GET_BITMAP(bitmap);
  return RB_BOOL(FreeImage_Invert(bitmap));
}

/*
 * call-seq:
 *   histogram(channel = FICC_RGB) -> array or nil
 *
 * Computes the image histogram. For 24-bit and 32-bit images,
 * histogram can be computed from red, green, blue and black
 * channels. For 8-bit images, histogram is computed from the black
 * channel. Other bit depth is not supported.
 * The method returns a 256 element array on success, nil otherwise.
 * See ImageScience::ColorChannels for accepted channel values.
 */
static VALUE histogram(int argc, VALUE *argv, VALUE self) {
  FIBITMAP *bitmap;
  DWORD histo[256];
  VALUE channel;  /* optional argument */
  FREE_IMAGE_COLOR_CHANNEL fi_chan;
  VALUE ret = Qnil;
  int i;

  rb_scan_args(argc, argv, "01", &channel);  /* 1 optional argument */
  
  fi_chan = NIL_P(channel) ? FICC_RGB : FIX2INT(channel);

  GET_BITMAP(bitmap);
  if(FreeImage_GetHistogram(bitmap, histo, fi_chan)) {
    ret = rb_ary_new2(256);
    for(i = 0; i < 256; i++) {
      rb_ary_store(ret, i, INT2FIX(histo[i]));
    }
  }
  return ret;
}

/* -- initialiser ---- */

void Init_image_science_ext(void)
{
  isc = rb_define_class("ImageScience", rb_cObject);
  rb_define_singleton_method(isc, "with_image", with_image, 1);
  rb_define_singleton_method(isc, "with_image_from_memory",
			     with_image_from_memory, 1);
  rb_define_singleton_method(isc, "get_version", get_version, 0);
  rb_define_singleton_method(isc, "file_type", file_type, 1);

  //rb_define_method(isc, "initialize", t_init, 0);
  rb_define_method(isc, "width", width, 0);
  rb_define_method(isc, "height", height, 0);
  rb_define_method(isc, "resize", resize, -1);
  rb_define_method(isc, "save", save, 1);
  rb_define_method(isc, "with_crop", with_crop, 4);
  rb_define_method(isc, "crop", with_crop, 4);
  rb_define_method(isc, "get_pixel_color", get_pixel_color, 2);
  rb_define_method(isc, "colortype", colortype, 0);
  rb_define_method(isc, "depth", depth, 0);
  rb_define_method(isc, "adjust_gamma", adjust_gamma, 1);
  rb_define_method(isc, "adjust_brightness", adjust_brightness, 1);
  rb_define_method(isc, "adjust_contrast", adjust_contrast, 1);
  rb_define_method(isc, "invert", invert, 0);
  rb_define_method(isc, "histogram", histogram, -1);  /* variable args */
  rb_define_method(isc, "buffer", buffer, -1);

  /* FREE_IMAGE_TYPE constants */
  isc_image_types = rb_define_module_under(isc, "ImageTypes");
  /* expand FreeImage constants isc_image_types FIT */

  /* FREE_IMAGE_COLOR_CHANNEL constants */
  isc_color_chan = rb_define_module_under(isc, "ColorChannels");
  /* expand FreeImage constants isc_color_chan FICC */

  /* FREE_IMAGE_COLOR_TYPE constants */
  isc_color_types = rb_define_module_under(isc, "ColorTypes");
  /* expand FreeImage constants isc_color_types FIC */

  /* FREE_IMAGE_FORMATS constants */
  isc_image_formats = rb_define_module_under(isc, "ImageFormats");
  /* expand FreeImage constants isc_image_formats FIF */

  /* IMAGE_FILTER constants */
  isc_image_filters = rb_define_module_under(isc, "ImageFilters");
  /* expand FreeImage constants isc_image_filters FILTER */

  /* load/save flag constants */
  isc_ls_flags = rb_define_module_under(isc, "LoadSaveFlags");
  /* expand FreeImage constants isc_ls_flags FLAG */

  FreeImage_SetOutputMessage(FreeImageErrorHandler);
}
